### 特集 1 Rust 入門

#### part1 言語の概要

- rust の強み

  - パフォーマンス
    - コンパイラ型の言語であり、コンパイラ時にメモリの使い方を決定するためメモリ効率がよく、高速である
  - 信頼性
    - 型システムと所有権モデルによるメモリ管理のおかげで、安全でないコード、スレッド間でデータ競合が起こる場合はコンパイラエラーになるため安全
  - 生産性
    - エラーメッセージの親切さ、パッケージマネージャやビルド補助ツールなどの開発ツールの豊富ざ、ドキュメントが見やすいなど開発がしやすい環境が整っている

- 所有権システム

  - 代入すると代入元の変数が使用しているメモリを解放する
    let x = 100
    let y = x
    x がここで解放され、移行では参照できない
    所有権を移さずに、データを代入する方法として、借用というものがある
    let x = 100
    let y = &x
    こうすることで、x のメモリは解放されず、これ以降も x を利用することができる

- トレイト
  - Rust では継承ができないが、代わりの仕組みとしてトレイトという仕組みがある
  - Java でいうインターフェースのような機能で、継承やポリモフィズムの表現に近い使い方ができる

#### part2 cargo を使いこなそう

- cargo コマンド

  - rustfmt:コードのフォーマットを整えてくれる
  - clippy:静的解析をする
  - test:テストコードを実行
  - add:パッケージの追加

- より便利に
  - cargo-make により Makefile.toml を作り、clippy,test を自動実行
  - エディタに rust の言語プラグインを導入し、保存時に自動フォーマット

#### part3 言語の強みを web 開発に活かす

- 本書の例では Actix Web,Serde,Diesel,libsqlite3-sys,anyhow,thiserror,Logger,NormalizePath を使い Web API を実装
- 後日手を動かして実装
- 細かい部分までは理解できていないが、実装の形は学べた

#### part4 小さく始めてプロダクトに Rust の良さを取り込もう

- サービス全体が複数のサーバシステムから構成されている場合、一部を Rust のサーバで置き換える

#### part5 WebAssembly でフロントエンドを実装する

- フレームワークとして Yew と seed-rs があり、Yew では react 風の関数コンポーネントと Hooks が用意されている

### 特集 2 初めての Elixir

- Elixir とは
  - ErlangVM 上で動く言語、Erlang で用意されたライブラリを利用できる

### 特集 3 実装して学ぶ HTTP/3

#### part1 HTTP/2 の問題点をどのように克服しているのか

- HTTP/2 の問題点

  - TCP を使っているので、届かないパケットがあった場合、それ以降のデータを渡すことができず、待機時間が発生してしまう。
  - 暗号化にハンドシェイクが 2 回も行われ、通信開始までに時間がかかる

- HTTP/3 でどのように解消されたか
  - TCP を捨て、新たに Quic を作った
  - これにより、パケット並び替えとストリーム制御が同じ枠組みとなり、届かないパケットがあった場合も、あるもののみでパケットの並び替えができるようになった。
  - また以前までは暗号化と接続のハンドシェイクを別々にしていたが、同時に行われるようになり、通信が開始できるまでの時間も短くなった。

#### part2 環境構築

- 本誌では ubuntu をベースにし、aioquic と呼ばれるライブラリを使用

- 実際にやったら方が理解できるので、後日実装してみる

#### part3 Quic サーバの基本機能を実装

- 本誌ではブラウザから届いたパケットのヘッダ情報、発生した Quic イベント、ブラウザに返信したパケットのヘッダ情報をコンソールに出力するまでを実装

- 実際にやったら方が理解できるので、後日実装してみる

#### part4 HTTP ヘッダやデータの取得方法を理解する

- 高速化するために HTTP 通信では、ハフマン不合格と辞書の使用でヘッダを圧縮し通信している。
- aioquic にはあらかじめ QPACK という辞書があるので、今回はそれを利用し、通信を行う。

- なおこの part も実装がメインなので、後日実装。

#### part5 代替サーバのしくみ、Retry パケットを理解

- HTTP/1 から HTTP/3 へアクセスを切り替えるには、HTTP/1 にアクセスした時に Alt-Svc というヘッダフィールドに代替サーバの情報をセットし、次回からは HTTP/3 を利用するようにする

- Retry パケットとは
  - 通信にはクライアントとサーバの Quic バージョンがあうように、バージョンネゴシエーションを行う必要がある。
  - その際に送信元が IP を偽装して、Initial パケットを送ってくるとサーバは別のクライアントとハンドシェイクを行おうとしてしまう。
  - そうなると関係ないところに大きなファイルを送ってしまい、最悪サーバやネットワークが落ちてしまう。
  - Retry パケットはサーバがクライアントに対し、トークンを送信するためのパケット
  - Retry パケットを受け取ったクライアントはトークンを含んだ Initial パケットを再度送信し、発行したトークンと一致するかを確認後にハンドシェイクをするので、先ほどの懸念がなくなる。
