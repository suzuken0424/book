### 特集 1 なぜコンテナ・Docker を使うのか？

#### part1 コンテナ普及の背景

- 現在のコンピュータでは一般的なマルチプロセス、同時に複数の処理ができるのが大きなメリット
  しかし、課題もある

  - 環境不整合の課題

    - 1 つのコンピュータではファイルシステムやライブラリなどはそれぞれ 1 つしか持てない
    - そのためあるアプリケーションは動作しても、他のアプリケーションで動作しないということが起きる

  - 安定性の問題

    - ハードウェアや OS カーネルが単一障害点となる

  - セキュリティの問題

    - 1 つの環境で全てのプロセスか動いている場合、特権ユーザーは全てのプロセスにアクセスできてしまう

  - リソースの問題
    - プロセスを別のコンピュータに移す場合、環境を作り直す必要があり、リソースの過不足に対して柔軟に対応できない

  現場での問題もある

  - コンピュータが増えていく

    - 環境共有の問題を避けるため、システムを構成する各種機能を別々のコンピュータで動作させようとする
    - しかし、その機能数分管理するコンピュータが増え、リソースの無駄も増える

  - 開発環境をそろえにくい
    - システム開発では開発環境、テスト環境、本番環境のそれぞれの環境を構築する必要がある
    - 比較的短い期間内では同じにしておくことは可能だが、時間が経つにつれてそれぞれの環境に違いが生じる
    - 特に本番環境ではセキュリティ対策のためのアップデートが開発環境では適応されておらず、開発段階で起きなかった不具合が本番環境で起きることがある

- サーバ仮想化技術やクラウドで解決できた課題/残った課題

  - 解決できた課題

    - 物理的なコンピュータの台数が減った
      - 物理マシンを仮想マシンへ変更したことで、物理マシンが減った
    - 環境維持が少し楽になった
      - 仮想マシンを丸ごとコピーするクローン機能によって、環境の不具合をある程度緩和することができた

  - 残った課題
    - 純重さは残ったまま
      - OS のインストールだけでも数百 MB 以上の容量が必要なので、作っては壊す俊敏な使い方ができない

- Docker はどんな問題を解決するのか
  - 鈍重さの解消
    - コンテナイメージは従来の 1/10 程度でインストールができ、迅速に起動できる
  - 隔離されたアプリケーションの実行
    - 別々のアプリが同じポート番号を利用できる
  - 自動化された開発環境
    - Dockerfile を使うことで環境構築を自動化できる
  - 開発者の環境を統一も簡単になった

#### part2 Docker、Kubernetes とランタイムの話

- kubernetes とは

  - コンテナをスケーラブルに管理するためのツール
  - YAML に実行したいイメージやコンテナ数を記載することで、その状態を保つように動作する

  - 基本的な実行単位 Pod
  - コンテナの 1 つ以上の集合
  - Pod 内のコンテナはローカルホストを利用し、通信を行う

- CRI ランタイムとは
  - kubelet からの指示に従い、Pod の実行やイメージの取得・管理などを行う

#### part3 移行の判断基準と AWS コンテナサービスの選定基準

- コンテナ移行の基準

  - 複数の環境で利用するか
  - 頻繁に変更するか
  - 負荷に応じてスケールさせるか

- AWS コンテナ関連サービスの種類

  - コンテナレジストリ

    - ビルドしたコンテナイメージを格納する場所
    - それを RUN することで実行する
    - 例)Docker Hub、Amazon ECR、Amazon ECR Public
    - Amazon ECR
    - フルマネージドなコンテナイメージレジストリサービス
    - ベースイメージを利用する場合は public を利用する

  - コンテナオーケストレーションサービス

    - コンテナをスケーラブルに管理するサービス
    - 例)Amazon ECS、Amazon EKS、AWS Fargate、App Runner

  - App Runner→ ECS on Fargate→ EKS on ECS の順で、システム要件を満たせるかを検討する

#### part4 本番運用に向けて考慮するべきこと

- コンテナオースケトレーションの選択
  - 先程紹介した AWS サービスの中からどれを利用するかを決める
  - コンテナイメージの CI/CD
  - コンテナイメージのビルドと kubernetes クラスタへのデプロイの流れを作る
  - ログ収集と監視方法
  - 今回は cloud watch cotainer insights を利用
  - 秘匿情報の管理
  - kubernetes 内の secrets に格納する
  - 可用性の確保
  - データベースのマイグレーション運用

### 特集 2 いま jamstack を始める理由

#### part1 勧める理由

- WEB サイトの複雑化を解消し、パフォーマンス、スケーラビリティ、柔軟性、保守性を高めれる

- jamstack とは

  - 表示する HTML を事前にレンダリングしておき、それを表示するアーキテクチャ
  - サイトの生成と配信する CDN と API を分離することで、動的な部分も実現できる
  - しかし、動的な部分が多いサイトは向いていない

- メリット
  - 静的が多く、攻撃ポイントを減らすことができる
  - CDN で配信しているので、CDN 側でキャッシュやアクセスに応じて適切にスケールができる
  - 静的ファイルの配信なので高速
  - シンプルなので、メンテナンスも簡単
  - 静的な WEB サイトとして生成されるので、ポスティングサービスに依存しない
  - API と分離したことで、ローカルで簡単に開発ができる

#### part2 5 つの WEB 技術との違いを理解する

- spa と jamstack

  - spa ではフロントで HTML を書き換える
  - jamstack は事前に表示する HTML をビルド時に構成する

- モダン WEB フレームワークと jamstack

  - jamstack の原則である事前に HTML を生成することされ守れば、jamstack といえる

- サーバレス構成と jamstack

  - jamstack ではサーバレスにしなければならない理由はない
  - なのでサーバレスだから jamstack というわけではない

- 静的生成 CMS と jamstack
  - CMS では同じサーバ内にデータベースを設置する必要があり、ローカルで開発するには Docker などを立てる必要がある
  - jamstack の場合はデータは API で取得するので、特別用意するものはない

#### part3 jamstack の入口

- GIT プロバイダの選定
  - 特に理由がなければ github で良い
- WEB フレームワークの選定
  - WEB サイトに近いものだと eleventy、astro などがおすすめ
  - ログインなどが必要な場合は next.js、skeltekit がおすすめ
- jamstack のポスティングサービスの選定
  - AWS たど amplify ポスティング、azure だと static web apps、GCP だと firebase hosting
  - その他として、netlify、vercel、cloudflare pages、github papes などがある
